# <center>**加载性能**</center>

<article align="left" padding="0 12px">

<style>
img[src*="#picwidth"]{
    width: 430px;
}
</style>

css加载方式和性能分析

### css加载方式

- 内联首屏关键CSS
- 异步加载CSS
- 资源压缩
- 合理使用选择器
- 减少使用昂贵的属性
- 不要使用@import
- h5新特性prefetch /preload

##### 内联首屏关键CSS
关键样式直接内联提升首页加载体验

##### 异步加载CSS
- 使用javascript将link标签插到head标签最后
```
// 创建link标签
const myCSS = document.createElement( "link" );
myCSS.rel = "stylesheet";
myCSS.href = "mystyles.css";
// 插入到header的最后位置
document.head.insertBefore( myCSS, document.head.childNodes[ document.head.childNodes.length - 1 ].nextSibling );
```
- 设置link标签media属性为noexis，浏览器会认为当前样式表不适用当前类型，会在不阻塞页面渲染的情况下再进行下载。加载完成后，将media的值设为screen或all，从而让浏览器开始解析CSS
```
<link rel="stylesheet" href="mystyles.css" media="noexist" onload="this.media='all'">
```
- 通过rel属性将link元素标记为alternate可选样式表，也能实现浏览器异步加载。同样别忘了加载完成之后，将rel设回stylesheet
```
<link rel="alternate stylesheet" href="mystyles.css" onload="this.rel='stylesheet'">
```
#### 资源压缩
利用webpack、gulp/grunt、rollup等模块化工具，将css代码进行压缩，使文件变小，降低浏览器的加载时间
#### 合理使用选择器
css匹配的规则是从右往左开始匹配，例如#markdown .content h3匹配规则如下：
- 先找到h3标签元素
- 然后去除祖先不是.content的元素
- 最后去除祖先不是#markdown的元素

如果嵌套的层级更多，页面中的元素更多，那么匹配所要花费的时间代价自然更高

所以我们在编写选择器的时候，可以遵循以下规则：
- 不要嵌套使用过多复杂选择器，最好不要三层以上
- 使用id选择器就没必要再进行嵌套
- 通配符和属性选择器效率最低，避免使用

#### 减少使用昂贵的属性
在页面发生重绘的时候，昂贵属性如box-shadow/border-radius/filter/透明度/:nth-child等，会降低浏览器的渲染性能
#### 不要使用@import
@import会影响浏览器的并行下载，使得页面在加载时增加额外的延迟，增添了额外的往返耗时
#### h5新特性prefetch(预读取) /preload(预加载)
声明式的获取（fetch）指令（兼容性？）
```html
<!-- 获取一项可能被“下一页访问”所需要的资源方式 -->
<!-- 相比于当前页面所需要的资源-较低优先级 -->
<link rel="prefetch"> 
<!-- 原本是计划处理当前页面的，但是在一些特别的场景失败了 -->
<!-- 也就是说大多数情况，即使没有 subresource，请求也是同一时机发出的 -->
<link rel="subresource"> 
<!--  加载资源一般是当前页面需要的，预先请求当前页面需要的资源（关键的脚本，字体，主要图片等） -->
<!-- 它有一个 as 属性，这可以让浏览器做到很多 subresource 和 prefetch 做不到的事情 -->
<!-- 有 onload 事件 -->
<!-- 不阻塞 window 的 onload 事件,可以定义资源加载完毕后的回调函数 -->
<link rel="preload"> 
```
https://blog.fundebug.com/2019/04/11/understand-preload-and-prefetch/
然后根据是否缓存标识决定是否存储在 HTTP 缓存中
https://zhuanlan.zhihu.com/p/32561606
#### 其他
- 减少重排操作，以及减少不必要的重绘
- 了解哪些属性可以继承而来，避免对这些属性重复编写
- cssSprite，合成所有icon图片，用宽高加上backgroud-position的背景图方式显- 现出我们要的icon图，减少了http请求
- 把小的icon图片转成base64编码
- CSS3动画或者过渡尽量使用transform和opacity来实现动画，不要使用left和top属性

参考:https://juejin.cn/post/6844903854690009102
</article>